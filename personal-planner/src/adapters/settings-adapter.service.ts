import { HttpClient } from '@angular/common/http';
import { inject, Injectable, signal } from '@angular/core';
import {
  ITimeFrameAvailabilityTemplate,
  ITimeSlot,
} from '../app/interfaces/time-slot';
import { BehaviorSubject, of } from 'rxjs';
import { ISettings } from '../app/interfaces/setting.interface';
import { IBalance } from '../app/interfaces/balance.interface';
import { AppStateService } from '../services/app-state.service';

@Injectable({
  providedIn: 'root',
})
export class SettingsAdapterService {
  private http = inject(HttpClient);
  // private appStateService = inject(AppStateService);
  
  settings$ = new BehaviorSubject<ISettings | undefined>(undefined);
  
  private days = [
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday',
    'Sunday',
  ];
  
  private timeFrameAvailability = signal<ITimeFrameAvailabilityTemplate>({
    name: 'Default template',
    description: 'Autogenerated template for availability',
    dailyAvailabilities: this.days.map((day, index) => ({
      dayIndex: index,
      timeSlots: [
        {
          start: { hour: 8, minutes: 0 },
          end: { hour: 20, minutes: 0 },
        } as ITimeSlot,
      ],
      isAvailable: true,
      isVisible: true,
      isEditable: true,
    })),
    useRatio: 0.5, // 50% of the time is available for tasks
  });
  
  private balances = signal<IBalance[]>([]);
  
  constructor() {}
  
  //TODO Implement when settings are available on the backend
  getSettings() {
    const settings: ISettings = {
      frameSettings: {
        availability: this.timeFrameAvailability(),
        balances: this.balances(),
      },
    };
    this.settings$.next(settings);
  }
  
  updateTimeSlots(changedDayTimeSlots: ITimeSlot[], dayIndex: number) {
    if (this.settings$.value) {
      const settingsClone = structuredClone(this.settings$.value);
      const modifiedDailyAvailabilities =
      settingsClone.frameSettings.availability.dailyAvailabilities.map(
        (availability, index) =>
          index === dayIndex
        ? { ...availability, timeSlots: changedDayTimeSlots }
        : availability
      );
      settingsClone.frameSettings.availability.dailyAvailabilities =
      modifiedDailyAvailabilities;
      this.settings$.next(settingsClone);
    }
  }
  
  updateAvailability(availability: boolean, dayIndex: number) {
    if(this.settings$.value) {
      const settingsClone = structuredClone(this.settings$.value);
      const targetDay = settingsClone.frameSettings.availability.dailyAvailabilities.find((item)=>item.dayIndex === dayIndex);
      if(targetDay) {
        targetDay.isAvailable = availability;
        this.settings$.next(settingsClone);
      }
      
    }
  }
  updateUseRatio(value: number) {
    if (this.settings$.value) {
      const settingsClone = structuredClone(this.settings$.value);
      settingsClone.frameSettings.availability.useRatio = value;
      this.settings$.next(settingsClone);
    }
  }
  
  addBalance(balance: IBalance) {
    if (this.settings$.value) {
      const settingsClone = structuredClone(this.settings$.value);
      settingsClone.frameSettings.balances.push(balance);
      this.settings$.next(settingsClone);
    }
  }

  updateBalances(balances: IBalance[]) {
    if (this.settings$.value) {
      const settingsClone = structuredClone(this.settings$.value);
      settingsClone.frameSettings.balances = balances;
      this.settings$.next(settingsClone);
    }
  }
}
